{% extends "graphgamel/index.html" %}

{% load adminmedia %}
{% load i18n %}

{% block branding %}
<h1 id="site-name">Sylva: Import Manager</h1>
{% endblock %}

{% block extracode %}
<script type="application/javascript">
var data = eval({{ json_data|safe }});
var valid_relations = eval({{ valid_relations|safe }});
var step = 0;

function manager(step) {
    function configure_trs(showing_list, hidden_list, blocked_list) {
        for(i=0;i<showing_list.length;i++) {
            tr_element = document.getElementById(showing_list[i]);
            tr_element.style.display = "";
            tr_element.style.disabled = false;
        }
        for(i=0;i<hidden_list.length;i++) {
            tr_element = document.getElementById(hidden_list[i]);
            tr_element.style.display = "none";
        }
        for(i=0;i<blocked_list.length;i++) {
            $('.'+blocked_list[i]).attr('disabled', true);
        }

    }
    document.getElementById('instructions').innerHTML = document.getElementById('instructions_'+step).innerHTML;
    switch (step) {
        case 0: // Data rows selection
            configure_trs([],["numbers_tr", "types_tr", "direction_tr", "collapse_tr",
                   "field1_tr", "field2_tr", "rfield1_tr", "rfield2_tr"], []);
            break;
        case 1: // Node generator type selection
            configure_trs(["types_tr"],["numbers_tr", "direction_tr", "collapse_tr",
                   "field1_tr", "field2_tr", "rfield1_tr", "rfield2_tr"], []);
            break;
        case 2:
            configure_trs(["direction_tr"], ["numbers_tr", "collapse_tr", "field1_tr",
                    "field2_tr", "rfield1_tr", "rfield2_tr"], ["column_selector"]);
            break;
        case 3:
            configure_trs(["collapse_tr"],["numbers_tr", "field1_tr", "field2_tr",
                    "rfield1_tr", "rfield2_tr"], ["column_selector", "direction_selector"]);
            break;
        case 4:
            configure_trs(["numbers_tr", "field1_tr", "field2_tr"], ["rfield1_tr",
                    "rfield2_tr"], ["column_selector", "direction_selector",
                    "collapse_selector"]);
            break;
        case 5:
            configure_trs(["rfield1_tr", "rfield2_tr"], ["numbers_tr"], ["column_selector", "direction_selector",
                    "collapse_selector", "field_selector", "tfield_selector"]);
            document.getElementById('finish').disabled = false;
            document.getElementById('next').disabled = true;
            break;
    }
}

function start_log() {
    document.getElementById('rows_canvas').innerHTML= "IMPORTATION LOG:<br/>";
}

function log_error(data_type, error_data) {
    jerror_data = JSON.stringify(error_data);
    document.getElementById('rows_canvas').innerHTML+= "Could not import " + data_type +
                                                    " with value " + jerror_data + "<br>";
}

function commitData() {
    document.getElementById('manager_buttons').style.display = "none";
    document.getElementById('instructions').style.display = "none";
    rows = document.getElementsByClassName('csv_selector');
    columns = document.getElementsByClassName('column_selector');
    fields = document.getElementsByClassName('field_selector');
    rfields = document.getElementsByClassName('rfield_selector');
    directions = document.getElementsByClassName('direction_selector');
    graph_data = {};
    direction_data = {};
    extra_fields = {}
    rextra_fields = [];
    new_nodes_to_collapse = [];
    new_nodes_to_duplicate = []
    new_relationships = [];
    // Checks node types and extra fields declared in header
    for(j=0;j<columns.length;j++) {
        item_id = "column_" + j;
        direction_id = "direction_" + j;
        extra_field_id = "field_" + j;
        rextra_field_id = "rfield_" + j;
        if (columns[item_id].value != "null") {
            graph_data[j] = columns[item_id].value;
            direction_data[j] = directions[direction_id].value;
        } else if (fields[extra_field_id].value != "null") {
            extra_fields[j] = [fields[extra_field_id].value, document.getElementById('key_'+j).value];
        }
        if (rfields[rextra_field_id].value != "null") {
            rextra_fields.push([rfields[rextra_field_id].value,
                                document.getElementById('rkey_'+j).value, j]);
        }
    }
    // Checks rows data...
    document.getElementById('progress_bar').innerHTML= "Creating nodes information..."
    for(i=0;i<rows.length;i++) {
        if (rows[i].checked) {
            // Creating nodes from the header declarations
            for(var j in graph_data) {
                if (data[i][j] != "")
                    node_info = {"type":graph_data[j], "id":data[i][j]};
                    // Searching additional fields for the node
                    for(var k in extra_fields) {
                        if ((extra_fields[k][0] == j) && (data[i][k] != "")) {
                            node_info[extra_fields[k][1]] = data[i][k];
                        }
                    } 
                    collapse = document.getElementById('collapse_'+j);
                    if (collapse.checked)
                        new_nodes_to_collapse.push(node_info);
                    else
                        new_nodes_to_duplicate.push(node_info);
            }
            // Searching relations between the fields of the row
            document.getElementById('progress_bar').innerHTML= "Creating relationships information..."
            for(k=0;k<valid_relations.length;k++) {
                for(var j in graph_data) {
                    if ((graph_data[j] == valid_relations[k].node_from) && (data[i][j] != "") 
                        && (direction_data[j] != "end")) {
                        for(var l in graph_data) {
                            if ((graph_data[l] == valid_relations[k].node_to) && (data[i][l] != "") 
                                && (direction_data[l] != "start")) {
                                relation_data = {};
                                for(m=0;m<rextra_fields.length;m++) {
                                    vr_id = rextra_fields[m][0];
                                    if (data[i][rextra_fields[m][2]] != "" && valid_relations[vr_id]['node_from'] == graph_data[j] &&
                                    valid_relations[vr_id]['relation'] == valid_relations[k].relation &&
                                    valid_relations[vr_id]['node_to'] == graph_data[l]) {
                                        relation_data[rextra_fields[m][1]] = data[i][rextra_fields[m][2]];
                                    }
                                }
                                new_relationships.push({"node_from": data[i][j],
                                        "node_from_type": graph_data[j],
                                        "relation": valid_relations[k].relation,
                                        "node_to": data[i][l],
                                        "node_to_type": graph_data[l],
                                        "data": relation_data});
                                break;
                            }
                        }
                        break;
                    }
                }
            }

        }
    }

    start_log();    
    // Creates the nodes in Sylva server

    total = new_nodes_to_collapse.length;
    for(i=0;i<new_nodes_to_collapse.length;i++) {
        $.ajax({url: "{% url graph.views.add_node_ajax graph_id %}", 
            data: {json_node: JSON.stringify(new_nodes_to_collapse[i]),
                    collapse: true},
            dataType: "json",
            async: false,
            success: function(response) {
                document.getElementById('progress_bar').innerHTML= "Processed " + i + " collapsable nodes of " + total;
            },
            error: function(response) {
                log_error("node", new_nodes_to_collapse[i]);
            }
        });
    }
    total = new_nodes_to_duplicate.length;
    for(i=0;i<new_nodes_to_duplicate.length;i++) {
        $.ajax({url: "{% url graph.views.add_node_ajax graph_id %}", 
            data: {json_node: JSON.stringify(new_nodes_to_duplicate[i]),
                    collapse: false},
            dataType: "json",
            async: false,
            success: function(response) {
                document.getElementById('progress_bar').innerHTML= "Processed " + i + " regular nodes of " + total;
            },
            error: function(response) {
                log_error("node", new_nodes_to_duplicate[i]);
            }

        });
    }
    // Creates the relationships in Sylva server
    total = new_relationships.length;
    for(i=0;i<new_relationships.length;i++) {
        $.ajax({url: "{% url graph.views.add_relationship_ajax graph_id %}", 
            data: {json_relation: JSON.stringify(new_relationships[i])},
            dataType: "json",
            async: false,
            success: function(response) {
                document.getElementById('progress_bar').innerHTML= "Processed " + i + " relationships of " + total;
            },
            error: function(response) {
                log_error("relationship", new_relationships[i]);
            }

        });
    }
    document.getElementById('progress_bar').innerHTML= "Import finished";
    
}

function start_configuration() {
    document.getElementById('selection_buttons').style.display = "none";
    document.getElementById('manager_buttons').style.display = "";
    step++;
    manager(step);
}

window.onload = function() {
    manager(step);
    document.getElementById('manager_buttons').style.display = "none";
}
</script>
{% endblock %}

{% block content %}
<div id="instructions" class="instructions"></div>
{% if rows %}
    <div id="selection_buttons">
        <button id="sall" onClick="$('.csv_selector').attr('checked',true);">Select all</button>
        <button id="dsall" onClick="$('.csv_selector').attr('checked',false);">Deselect all</button>
        <button id="startbtn" onClick="start_configuration();">Next</button>
    </div>
    <div id="manager_buttons">
        <button id="next" onClick="step++;manager(step);">Next</button>
        <button id="finish" disabled="true" onClick="commitData()">Finish</button>
    </div>
    <p id="progress_bar"/>
{% endif %}
<div id="rows_canvas">
<table>
    <tr id="numbers_tr">
    <td></td>
    {% for item in len %}
        <td>{{ item }}</td>
    {% endfor %}
    </tr>
    <tr id="types_tr">
    <td></td>
    {% for item in len %}
        <td><select class="column_selector" id="column_{{ item }}">
            <option value="null">- - - -</option>
            {% for node_type in node_types %}
                <option value="{{ node_type }}">{{ node_type }}</option>
            {% endfor %}
        </select></td>
    {% endfor %}
    </tr>
    <tr id="direction_tr">
    <td></td>
    {% for item in len %}
        <td><select class="direction_selector" id="direction_{{ item }}">
            <option value="null">- - - -</option>
            <option value="start">Start</option>
            <option value="end">End</option>
        </select></td>
    {% endfor %}
    </tr>
    <tr id="collapse_tr">
    <td></td>
    {% for item in len %}
        <td>
            <input id="collapse_{{ forloop.counter0 }}"
                    class="collapse_selector"
                    type="checkbox" checked>
        </td>
    {% endfor %}
    </tr>
    <tr id="field1_tr">
    <td></td>
    {% for item in len %}
        <td><select class="field_selector" id="field_{{ item }}">
                <option value="null">- - - -</option>
                {% for item in len %}
                    <option value="{{ item }}">{{ item }}</option>
                {% endfor %}
            </select>
        </td>
    {% endfor %}
    </tr>
    <tr id="field2_tr">
    <td></td>
    {% for item in len %}
        <td>
            <input type="text" id="key_{{ item }}" size="4" class="tfield_selector"/>
        </td>
    {% endfor %}
    </tr>
    <tr id="rfield1_tr">
    <td></td>
    {% for item in len %}
        <td><select class="rfield_selector" id="rfield_{{ item }}">
                <option value="null">- - - -</option>
                {% for r in relations %}
                    <option value="{{ forloop.counter0 }}">{{ r.node_from }} {{ r.relation }} {{ r.node_to }}</option>
                {% endfor %}
            </select>
        </td>
    {% endfor %}
    </tr>
    <tr id="rfield2_tr">
    <td></td>
    {% for item in len %}
        <td>
            <input type="text" id="rkey_{{ item }}" size="4"/>
        </td>
    {% endfor %}
    </tr>
    {% for row in rows %}
    <tr>
        <td><input id="row_{{ forloop.counter0 }}"
                    class="csv_selector"
                    type="checkbox"></td>
        {% for csv_field in row %}
            <td>{{ csv_field }}</td>
        {% endfor %}
    </tr>
    {% endfor %}
</table>
</div>
<div id="instructions_0" class="hidden">
<p>You should see below all the data included in your CSV file in a tabular 
distribution. Select the rows you wish to import. You can also use the 
<strong>Select/Deselect All</strong> buttons.</p> 
<p>Press <strong>Next</strong> when you are done.</p>
</div>
<div id="instructions_1" class="hidden">
<p>Now, you have to choose which columns of your CSV file are going to 
generate new nodes in the graph database. You just need to select the
type that a column generates and leave the rest in blank (- - - -).</p>
<p>You shouldn't choose the same type in more than two columns.</p>
<p>Press <strong>Next</strong> when you are done.</p>
</div>
<div id="instructions_2" class="hidden">
<p>As you may know, Sylva graph databases are directed. This means that
relationships between elements are from one node to another and not in
the reverse way unless it is explicitly specified.</p>
<p>Sylva Importer will try to find every possible relation between your
fields but if you want to declare some of them as "Only Start" or 
"Only End" you can do it by selecting the correct option in the following
controls.</p>
<p>Press <strong>Next</strong> when you are done.</p>
</div>
<div id="instructions_3" class="hidden">
<p>By default, Sylva will recognize common values in your columns and it will
generate the node once. If you want to avoid this behaviour for one of 
your columns, just uncheck the desired control.</p>
<p>Press <strong>Next</strong> when you are done.</p>
</div>
<div id="instructions_4" class="hidden">
<p>You may want to use some of the remaining columns to create fields of the
nodes created.</p>
<p>A little number has appeared over each of the columns. If you want to associate
a column with another, just select the number of the index in the selector and enter
a name in the text input. This name will be the key of the property that will be 
generated in the node.</p>
<p>Press <strong>Next</strong> when you are done.</p>
</div>
<div id="instructions_5" class="hidden">
<p>As well as node properties, you may want to create relationship properties. Similar 
to the previous step, select the desired relationship type in the selector and enter
below the key of the property that will be generated.</p>
<p>Press <strong>Finish</strong> to start the importation process. Depending of the 
number of rows this process can take a long time.</p>
</div>
<div id="instructions_6" class="hidden">
Help 6
</div>
{% endblock %}
